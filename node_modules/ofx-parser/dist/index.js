"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = parseOfx;
exports.serialize = serializeOfx;
const xml2js_1 = require("xml2js");
function convertSgmlToXml(sgml) {
    return sgml
        .replace(/>\s+</g, '><') // Remove whitespace between tags
        .replace(/\s+</g, '<') // Remove whitespace before a tag
        .replace(/>\s+/g, '>') // Remove whitespace after a tag
        .replace(/<([A-Z0-9_]*)+\.+([A-Z0-9_]*)>([^<]+)/g, '<$1$2>$3')
        .replace(/<(\w+?)>([^<]+)/g, '<$1>$2</$1>');
}
function parseXml(content) {
    return __awaiter(this, void 0, void 0, function* () {
        return (0, xml2js_1.parseStringPromise)(content, {
            explicitArray: false,
        });
    });
}
function parseOfx(data) {
    return __awaiter(this, void 0, void 0, function* () {
        // Split the data into headers and body based on the '<OFX>' tag
        const [headerText, bodyText] = data.split('<OFX>', 2);
        // Parse headers into a key-value object
        const headers = {};
        for (const line of headerText.split(/\r?\n/)) {
            const [key, value] = line.split(':', 2);
            if (key && value) {
                headers[key.trim()] = value.trim();
            }
        }
        // Reconstruct the body with the '<OFX>' tag
        const content = `<OFX>${bodyText}`;
        // Attempt to parse the body as XML
        let parsedData;
        try {
            parsedData = yield parseXml(content);
        }
        catch (_a) {
            // If parsing fails, convert SGML to XML and retry
            const xmlContent = convertSgmlToXml(content);
            parsedData = yield parseXml(xmlContent);
        }
        // Attach headers to the parsed data
        return {
            header: headers,
            OFX: parsedData.OFX,
        };
    });
}
function objectToOfx(value) {
    let output = '';
    if (typeof value === 'object' && value !== null) {
        if (Array.isArray(value)) {
            for (const item of value) {
                output += objectToOfx(item);
            }
        }
        else {
            const obj = value;
            for (const key of Object.keys(obj)) {
                const val = obj[key];
                const startTag = `<${key}>`;
                const endTag = `</${key}>`;
                output += `${startTag}${objectToOfx(val)}${endTag}\n`;
            }
        }
    }
    else {
        output += `${value}\n`;
    }
    return output;
}
function serializeOfx(headers, body) {
    let output = '';
    // Specify the order of headers
    const headerOrder = [
        'OFXHEADER',
        'DATA',
        'VERSION',
        'SECURITY',
        'ENCODING',
        'CHARSET',
        'COMPRESSION',
        'OLDFILEUID',
        'NEWFILEUID',
    ];
    // Append headers to the output
    for (const key of headerOrder) {
        if (headers[key]) {
            output += `${key}:${headers[key]}\n`;
        }
    }
    output += '\n';
    // Convert the body object to OFX format and append
    output += objectToOfx({ OFX: body });
    return output;
}
//# sourceMappingURL=index.js.map